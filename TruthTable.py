{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''\n",
    "    Author: Gacoka Mbui\n",
    "    Date: 6th October 2019\n",
    "    \n",
    "    Accepted inputs include:\n",
    "    ------------------------\n",
    "    Examples: a and b or c\n",
    "            : (A and B) implies z or f\n",
    "            : A v B and E\n",
    "    \n",
    "    The user_input function takes in the user inputs \n",
    "    while the get_atomic_sentences function extracts all the atomic\n",
    "    sentences from the logical statement. The nextprevword function \n",
    "    takes the words before and after the string being analyzed. \n",
    "    return_value and printTruthTable returns the truth values\n",
    "    of the logical statements and printing the truth table respectively.'''\n",
    "from prettytable import PrettyTable # inportation of the Table display library\n",
    "\n",
    "print(\"Enter your logical statement e.g. (a and b) implies c / a ↔ b v c / a biconditional b\")\n",
    "inputt = input(\"\\n **Ensure there is space between the atomic sentences and the connectives!!**\\n> \")\n",
    "inp = inputt.lower()\n",
    "            \n",
    "def user_input(): #function accepts user input\n",
    "    global inp #declaring the user input value to be used\n",
    "    for n, i in enumerate(inp): #for all the string's characters, change them \n",
    "                                # to their respective python comparisons\n",
    "        if i == \"&\" or i == \"&&\" or i == \"^\":\n",
    "            inp = inp.replace(\"&\" or \"&&\" or \"^\", \"and\")\n",
    "        elif i == \"→\" or i == \"implication\":\n",
    "            inp = inp.replace(\"→\" or \"implication\",\"implies\")\n",
    "        elif i == \"↔\" or i == \"xnor\":\n",
    "            inp = inp.replace(\"↔\" or \"xnor\",\"biconditional\")\n",
    "        elif i == \"v\":\n",
    "            inp = inp.replace(\"v\" ,\"or\")            \n",
    "        else:\n",
    "            continue\n",
    "    print(\"\\nThis is your input: \" + inp)\n",
    "    return str(inp) #returns users cleaned outputs\n",
    "\n",
    "def get_atomic_sentences(): #function extracts the atomic sentences from the \n",
    "    global inp #declaration of global variable of the users input\n",
    "    char_set = [\"and\", \"or\", \"implies\", \"biconditional\", \"&\", \"&&\", \"v\", \"^\",\\\n",
    "                \"→\", \"↔\", \"xnor\", \"(\", \")\", \"not\"]\n",
    "    atomic_sentences = []\n",
    "    input1 = ''.join(c for c in inp if c not in '()')\n",
    "    input2 = input1.split(\" \")\n",
    "    unique = set(input2)\n",
    "    unique = list(unique)\n",
    "    for i in unique:\n",
    "        if i not in char_set:\n",
    "            atomic_sentences.append(i)\n",
    "    atomic_sentences.sort()\n",
    "    return list(atomic_sentences), input2\n",
    "\n",
    "def nextprevword(target, source): #function\n",
    "    for i, w in enumerate(source): #loops through the strings (number, word)\n",
    "        if w == target: # if the word is equal to the string being searched\n",
    "            last = ','.join(source[i+1:]) #extract all the strings after the word\n",
    "            last = last.replace(\",\", \" \") #replacement used for storing \n",
    "                                            #the strings to a list\n",
    "\n",
    "            first = ','.join(source[:i]) #extracts all the strings before the word\n",
    "            first = first.replace(\",\", \" \") #replacement used for storing the strings to a list\n",
    "            return first, last #returns the previous and words that occur after\n",
    "        \n",
    "def return_value(answer): #accepts a list of all the logical statement\n",
    "    global inp\n",
    "    atomic_dict, input2 = get_atomic_sentences() #calls get_atomic_sentences \n",
    "                                                    #to use atomic sentences and user input\n",
    "    for n, i in enumerate(atomic_dict): # loops through all the atomic sentences\n",
    "        exec(i + f\" = {answer[n]}\") # defines the true, false value to each\n",
    "    if 'implies' in inp: #if the string implies is found in the users input\n",
    "        previous, after = nextprevword('implies', input2) #call nextpervword to get \n",
    "                                                            #words that come before and after\n",
    "        inp = not previous or after #implication function\n",
    "        evaluation = eval(inp) #evaluate the truth value of the implication function\n",
    "    elif 'biconditional' in inp: #if biconditional found in user input\n",
    "        previous, after = nextprevword('biconditional', input2) \n",
    "        if(previous == after): #elif clause performs the biconditional logic in Python\n",
    "            evalution = True\n",
    "        else: \n",
    "            evaluation = False\n",
    "    else:\n",
    "        if 'biconditional' in inp and 'implies' in inp: #if both the words 'biconditional'\n",
    "                                                        #and 'implies' are found throw error\n",
    "            print(\"You can not have an implication and biconditional in the same statement.\")\n",
    "            exit() #and exit\n",
    "        evaluation = eval(inp)\n",
    "    return evaluation #return the truth value after the evaluation of the atomic sentence\n",
    "\n",
    "def printTruthTable(): #function to print truth table\n",
    "    inp = user_input() #calls user_input function for users input\n",
    "    \n",
    "    atomic_dict, input2 = get_atomic_sentences() #calls the get_atomic_sentences \n",
    "                                                    #function to get atomic sentences and user input\n",
    "    x = PrettyTable([n for n in atomic_dict + [str(inp)]])\n",
    "    p = len(atomic_dict) #define p which is the length of the list atomic_dict (number of atomic sentences)\n",
    "    print(\"Your logical statement has \" + str(p) + \" atomic sentences.\")\n",
    "\n",
    "    def permutation(n): #permutation function to print truth table\n",
    "        if n < 1: #if the value of n is less than one because it decreases\n",
    "                #by calling itself, add a blank list (recursion)\n",
    "            return [[]]\n",
    "        subtable = permutation(n-1) #call the function and reduce by 1\n",
    "        return [row + [v] for row in subtable for v in [True,False]] #return the true-false values of our atomic sentences\n",
    "\n",
    "    truth_table = permutation(p)\n",
    "    for i in range(2**p):\n",
    "        x.add_row(truth_table[i] + [return_value(truth_table[i])]) #add rows true-false permutation,\n",
    "                                                                    #values of the atomic sentences\n",
    "    print(x) #print truth table\n",
    "\n",
    "printTruthTable() #call the printTruthTable function"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
